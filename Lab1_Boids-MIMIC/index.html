<!DOCTYPE html>
<html>
  <head>
    
      <script>
        window.onerror = function(error, url, line) {
          parent.postMessage(["console", "\"Error on line[" + (line-1) + "]:" + error + "\""], "*")
        };
        window.addEventListener("unhandledrejection", function (event) {
          parent.postMessage(["console", "\"Error:Uncaught " + event.reason + "\""], "*")
        });
        function prettyPrint(obj, indent = 0, seen = new Map()) {
          
          let result = '';
          let baseIndent = ' '.repeat(indent);
          let newIndent = baseIndent + '    ';
          try {
          if (seen.has(obj)) {
              return `${baseIndent}"[Circular Reference (${seen.get(obj)})]"`;
          }
      
          if (typeof obj === 'object' && obj !== null) {
              seen.set(obj, seen.size + 1);
      
              if (Array.isArray(obj)) {
                  result += '[';
                  for (let i = 0; i < obj.length; i++) {
                      if (i > 0) {
                          result += ',';
                      }
                      const value = obj[i];
                      if (typeof value === 'object' && value !== null) {
                          result += '\n' + prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          result += `\n${newIndent}"${value}"`;
                      } else if (typeof value === 'function') {
                        result += `\n${newIndent}"[Function]"`;
                      }  else if (value === undefined) {
                        result += `\n${newIndent}"[undefined]"`;
                      }
                      else {
                        result += `\n${newIndent}${value}`;
                      }
                  }
                  result += `\n${baseIndent}]`;
              } else {
                  result += '{\n';
                  let entries = Object.keys(obj).map((key) => {
                      const value = obj[key];
                      let entry = `${newIndent}"${key}": `;
                      if (typeof value === 'object' && value !== null) {
                          entry += prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          entry += `"${value}"`;
                      } else if (typeof value === 'function') {
                        entry += `\n${newIndent}"[Function]"`;
                      } else if (value === undefined) {
                        entry += `\n${newIndent}"[undefined]"`;
                      } else {
                          entry += value;
                      }
      
                      return entry;
                  });
      
                  result += entries.join(',\n');
                  result += `\n${baseIndent}}`;
              }
          } else {
              if (typeof obj === 'string') {
                  result += `"${obj}"`;
              } else {
                  result += obj.toString();
              }
          }
        } catch (err) {
          result = "error making json string"
        }
      
          return result;
      }
        </script><script crossorigin src="../libs/p5.min.js">
</script>
    <meta charset="utf-8" />
    <title>The Nature of Code Example 6.9 Flocking</title>
    <style type = "text/css" >
html, body {
 margin: 0;
 padding: 0;
}
canvas {
  display: block;
}

</style>
  </head>
  <body>
    <script language="javascript" type="text/javascript">
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

// Boid class
// Methods for Separation, Cohesion, Alignment added

class Boid {
  constructor(x, y) {
    this.acceleration = createVector(0, 0);
    this.velocity = createVector(random(-1, 1), random(-1, 1));
    this.position = createVector(x, y);
    this.r = 3.0;
    this.maxspeed = 3; // Maximum speed
    this.maxforce = 0.05; // Maximum steering force
    
    this.seperationStrength = 1.5;
    this.alignmentStrength = 1.0;
    this.cohesionStength = 1.0;
  }

  run(boids) {
    this.flock(boids);
    this.update();
    this.borders();
    this.show();
  }
  
  setMaxSpeed(maxSpeed) {
    this.maxspeed = maxSpeed;
  }
  
 setSeparationStrength(strength) {
    this.separationStrength = strength;
  }

  setAlignmentStrength(strength) {
    this.alignmentStrength = strength;
  }

  setCohesionStrength(strength) {
    this.cohesionStrength = strength;
  }
  
  applyForce(force) {
    // We could add mass here if we want A = F / M
    this.acceleration.add(force);
  }

  // We accumulate a new acceleration each time based on three rules
  flock(boids) {
    let sep = this.separate(boids); // Separation
    let ali = this.align(boids); // Alignment
    let coh = this.cohere(boids); // Cohesion
    
    // Arbitrarily weight these forces
    sep.mult(this.seperationStrength);
    ali.mult(this.alignmentStrength);
    coh.mult(this.cohesionStength);
    
    // Add the force vectors to acceleration
    this.applyForce(sep);
    this.applyForce(ali);
    this.applyForce(coh);
  }

  // Method to update location
  update() {
    // Update velocity
    this.velocity.add(this.acceleration);
    // Limit speed
    this.velocity.limit(this.maxspeed);
    this.position.add(this.velocity);
    // Reset accelertion to 0 each cycle
    this.acceleration.mult(0);
  }

  // A method that calculates and applies a steering force towards a target
  // STEER = DESIRED MINUS VELOCITY
  seek(target) {
    let desired = p5.Vector.sub(target, this.position); // A vector pointing from the location to the target
    // Normalize desired and scale to maximum speed
    desired.normalize();
    desired.mult(this.maxspeed);
    // Steering = Desired minus Velocity
    let steer = p5.Vector.sub(desired, this.velocity);
    steer.limit(this.maxforce); // Limit to maximum steering force
    return steer;
  }

  show() {
  // Draw a fish-like shape rotated in the direction of velocity
  let angle = this.velocity.heading();
  fill(0, 0, 255); // Blue color for the fish
  noStroke(); // No border for the fish
  push();
  translate(this.position.x, this.position.y);
  rotate(angle);

  // Fish body
  ellipse(0, 0, 20, 10);

  // Fish tail
  beginShape();
  vertex(-10, -5);
  vertex(-20, 0);
  vertex(-10, 5);
  endShape(CLOSE);

  pop();
}

  // Wraparound
  borders() {
    if (this.position.x < -this.r) this.position.x = width + this.r;
    if (this.position.y < -this.r) this.position.y = height + this.r;
    if (this.position.x > width + this.r) this.position.x = -this.r;
    if (this.position.y > height + this.r) this.position.y = -this.r;
  }

  // Separation
  // Method checks for nearby boids and steers away
  separate(boids) {
    let desiredSeparation = 25;
    let steer = createVector(0, 0);
    let count = 0;
    // For every boid in the system, check if it's too close
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if (d > 0 && d < desiredSeparation) {
        // Calculate vector pointing away from neighbor
        let diff = p5.Vector.sub(this.position, boids[i].position);
        diff.normalize();
        diff.div(d); // Weight by distance
        steer.add(diff);
        count++; // Keep track of how many
      }
    }
    // Average -- divide by how many
    if (count > 0) {
      steer.div(count);
    }

    // As long as the vector is greater than 0
    if (steer.mag() > 0) {
      // Implement Reynolds: Steering = Desired - Velocity
      steer.normalize();
      steer.mult(this.maxspeed);
      steer.sub(this.velocity);
      steer.limit(this.maxforce);
    }
    return steer;
  }

  // Alignment
  // For every nearby boid in the system, calculate the average velocity
  align(boids) {
    let neighborDistance = 50;
    let sum = createVector(0, 0);
    let count = 0;
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      if (d > 0 && d < neighborDistance) {
        sum.add(boids[i].velocity);
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(this.maxspeed);
      let steer = p5.Vector.sub(sum, this.velocity);
      steer.limit(this.maxforce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }

  // Cohesion
  // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
  cohere(boids) {
    let neighborDistance = 50;
    let sum = createVector(0, 0); // Start with empty vector to accumulate all locations
    let count = 0;
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      if (d > 0 && d < neighborDistance) {
        sum.add(boids[i].position); // Add location
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      return this.seek(sum); // Steer towards the location
    } else {
      return createVector(0, 0);
    }
  }
}

</script>
    <script language="javascript" type="text/javascript">
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

// Flock object
// Does very little, simply manages the array of all the boids

class Flock {

  constructor() {
    // An array for all the boids
    this.boids = []; // Initialize the array

    // create separation slider, bind "this" context
    this.separationSlider = createSlider(0, 5, 1.5, 0.01);
    this.onSeparationSliderChange = this.onSeparationSliderChange.bind(this);
    this.separationSlider.input(this.onSeparationSliderChange);

    // create alignment slider, bind "this" context
    this.alignmentSlider = createSlider(0, 5, 1, 0.01);
    this.onAlignmentSliderChange = this.onAlignmentSliderChange.bind(this);
    this.alignmentSlider.input(this.onAlignmentSliderChange);

    // create cohesion slider, bind "this" context
    this.cohesionSlider = createSlider(0, 5, 1, 0.01);
    this.onCohesionSliderChange = this.onCohesionSliderChange.bind(this);
    this.cohesionSlider.input(this.onCohesionSliderChange);

    // Add an initial set of boids into the system
    for (let i = 0; i < 120; i++) {
      let boid = new Boid(width / 2, height / 2);
      this.addBoid(boid);
    }
  }
  
onSeparationSliderChange() {
    const separationStrength = this.separationSlider.value();

    this.boids.forEach(function (boid) {
      boid.setSeparationStrength(separationStrength);
    });
  }

  onAlignmentSliderChange() {
    const alignmentStrength = this.alignmentSlider.value();

    this.boids.forEach(function (boid) {
      boid.setAlignmentStrength(alignmentStrength);
    });
  }

  onCohesionSliderChange() {
    const cohesionStrength = this.cohesionSlider.value();

    this.boids.forEach(function (boid) {
      boid.setCohesionStrength(cohesionStrength);
    });
  }

  run() {
    for (let boid of this.boids) {
      boid.run(this.boids); // Passing the entire list of boids to each boid individually
    }
  }

  addBoid(b) {
    this.boids.push(b);
  }
}
</script>
    <script language="javascript" type="text/javascript">
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

// Demonstration of Craig Reynolds' "Flocking" behavior
// See: http://www.red3d.com/cwr/
// Rules: Cohesion, Separation, Alignment

// Click mouse to add boids into the system

let flock;

function setup() {
  createCanvas(720, 540);
  flock = new Flock();
  // Add an initial set of boids into the system
  for (let i = 0; i < 120; i++) {
    let boid = new Boid(width / 2, height / 2);
    flock.addBoid(boid);
  }
}

function draw() {
  background(255);
  flock.run();
}

// Add a new boid into the System
function mouseDragged() {
  flock.addBoid(new Boid(mouseX, mouseY));
}

</script>
  </body>
</html>
